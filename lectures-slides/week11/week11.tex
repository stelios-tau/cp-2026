
\PassOptionsToPackage{colorlinks,linkcolor={blue},citecolor={blue},urlcolor={blue},breaklinks=true,final}{hyperref}
\PassOptionsToPackage{dvipsnames}{xcolor}
\documentclass[xcolor={dvipsnames,svgnames},aspectratio=169]{beamer}

\usepackage{fontawesome5}
\usepackage{booktabs} % For better table formatting
\usepackage{listings}

\lstset{
  tabsize = 4, %% set tab space width
  showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
  numbers = left, %% display line numbers on the left
  commentstyle = \color{purple!60}, %% set comment color
  keywordstyle = \color{blue}, %% set keyword color
  stringstyle = \color{red}, %% set string color
  rulecolor = \color{black}, %% set frame color to avoid being affected by text color
  basicstyle = \small \ttfamily , %% set listing font and size
  breaklines = true, %% enable line breaking
  numberstyle = \tiny,
}

\title{Concurrent Programming}
\subtitle{Week 11 (Lecture 4)}
\author{Stelios Tsampas}
\institute{
  \faEnvelope \; stelios@imada.sdu.dk
  \qquad
  \faGlobe \;
  \href{https://www.steliostsampas.com}{https://www.steliostsampas.com}
  \\\\\
  \faGithub \; stelios-tau/cp-2025
  \qquad\;\;
    \faDiscord \; cp-2025
}
\date{March 11, 2025}

\titlegraphic{\includegraphics[height=0.6cm,keepaspectratio]{../media/sdu-black.eps}}

\usetheme[block=fill]{metropolis}


%\usepackage{pres-common}
\usepackage{textpos}
\usepackage{centernot}

% \newcommand{\Goesv}[3]{\ensuremath{#1 \xRightarrow{~#3~} #2}}
% \newcommand{\goesv}[3]{\ensuremath{#1 \xrightarrow{~#3~} #2}}

% \usepackage{etex}
% \usepackage{semantic}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{tikz}
\usepackage{hyperref}

\usetikzlibrary{arrows,shapes,matrix}
\usetikzlibrary{backgrounds}
\usetikzlibrary{positioning}
\usetikzlibrary{automata}
\usetikzlibrary{mindmap}
\usetikzlibrary{shapes.callouts}
\usetikzlibrary{decorations.text}
\usetikzlibrary{tikzmark}
\usetikzlibrary{calc}
\usetikzlibrary{overlay-beamer-styles}
\usetikzlibrary{shapes.geometric}

\tikzset{onslide/.code args={<#1>#2}{%
    \only<#1>{\pgfkeysalso{#2}} % \pgfkeysalso doesn't change the path
  }}

\setbeamercolor{mygray}{bg=Gray!20}

\tikzset{temporal/.code args={<#1>#2#3#4}{%
    \temporal<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}}{\pgfkeysalso{#4}} % \pgfkeysalso doesn't change the path
  }}

\tikzstyle{highlight}=[fill=green!50]
\tikzstyle{hgreen}=[fill=green!20]
\tikzstyle{hred}=[fill=red!50]
\tikzstyle{hblue}=[fill=blue!50]
\tikzstyle{hgray}=[fill=gray!50]

\addtobeamertemplate{frametitle}{}{%
\begin{textblock*}{100mm}(\textwidth-2cm,-0.86cm)
\includegraphics[height=0.6cm,keepaspectratio]{../media/sdu-white.eps}
\end{textblock*}}


%\usepackage{tikz-cd}
% \usepackage{wasysym}
% \usepackage{color}
% \usepackage[matrix,arrow]{xy}
% \xyoption{all}
% \SelectTips{cm}{}
% % \usepackage{cite}
% \usepackage{amsthm}
% \usepackage{amsmath}
% \usepackage{bbold}
% % \usepackage[bbgreekl]{mathbbol}
% \usepackage{amssymb}
% \usepackage{pifont}
% \usepackage{mathtools}
% \usepackage{amsbsy}
% % \usepackage{paralist}
% \usepackage{shadethm}
% % \usepackage{fancyhdr}
% \usepackage{stmaryrd}
% \usepackage{wasysym}
% \usepackage{graphicx}
% \usepackage{tabularx}
% \usepackage{dsfont}
% \usepackage{ulem}




%\bibliography{mainBiblio}

%\includeonlyframes{current}
\begin{document}

\frame{\titlepage}

\def\firstcircle{(0,0) circle (2cm)}
\def\secondcircle{(1.4,1.4) circle (2cm)}
\def\thirdcircle{(0:2.4) circle (2cm)}

\begin{frame}{Outline}
  \tableofcontents
\end{frame}

\section{Recap and introduction}

\begin{frame}[fragile]
  \frametitle{Last week's topics}

  Last week, we touched upon...

  \begin{itemize}
  \item[\faBook]<1-> The fundamental problem of sharing mutable state.
  \item[\faBook]<1-> Atomicity, i.e. the property of a sequence of
    statements appearing \emph{indivisible} w.r.t. other threads.
  \item[\faBook]<1-> How to achieve atomicity and protect code against
    concurrent access by other threads using \emph{intrinsic locks}.
  \item[\faUserInjured]<1-> Several examples of race conditions and how to fix them.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Last week vs this week}

  \large{Last week was more about specific problematic patterns occurring during
    the execution of a \emph{program}.}

  \pause

  \large{This week will be more about \emph{designing} software that can be
    \emph{utilized} safely in a concurrent setting.}

\end{frame}

\begin{frame}[fragile]
  \frametitle{This week's topics}

  This week, we will witness that

  \begin{itemize}
  \item[\faBook]<1-> Java subverts common sense
    on a concurrent setting, due to \emph{visibility}.
  \item[\faBook]<1-> Preparing to \emph{share} an object across threads
    is not as simple as it sounds, due to timing and visibility problems.
  \item[\faBook]<1-> Notions such as \emph{invariants}, \emph{immutability} and
    \emph{encapsulation} play a central role in designing thread-safe classes.
  \end{itemize}

  \begin{itemize}
  \item[\faUserInjured]<2-> We will also demonstrate all of the above in
    examples.
  \end{itemize}
\end{frame}


\section{Visibility}

\begin{frame}[fragile]
  \frametitle{More than just locking}

  \begin{itemize}
  \item[\faBook]<1-> Intrinsic locks ensure that only one thread may enter any
    piece of code that is protected by the same lock.
  \item[\faBook]<1-> It also has a second purpose: it makes updates in one
    thread \emph{visible} to other threads!
    \begin{itemize}
    \item[\faUserInjured]<2-> Without synchronization, this might not happen!
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Is this thread-safe?}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
class KeepsGoing extends Thread {
    boolean keepRunning = true;

    public void run() {
        while (keepRunning) {
            doSomething();
        }
    }
}
\end{lstlisting}

    \uncover<3->{
    \begin{itemize}
    \item[\faUserInjured] There is no guarantee that changes to
      \texttt{keepRunning} by other threads will be visible in this thread.
    \item[\faBriefcaseMedical] We have to use synchronization!
    \end{itemize}}
  \uncover<2->{
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=3cm,starburst,starburst points=20,
      align=center,fill=yellow, opacity=1,draw=red, line width=2pt]
      {\textbf{No! \faSkullCrossbones}};
    \end{tikzpicture}}



\end{frame}

\begin{frame}[fragile]
  \frametitle{Visibility}

  \begin{itemize}
  \item[\faBook] The developer might expect that writes should be
    \emph{visible} to any access that took place \emph{after} (in terms of
    universal time) a write.
  \item[\faUserInjured] However, this is \textbf{not} the case:
    \begin{itemize}
    \item[\faBook] Java does not guarantee when a write in some thread will be
      visible to other threads.
    \item[\faBook] \uncover<2->{Java doesn't even guarantee that writes will be visible
      \textbf{at all}!!}
    \end{itemize}
  \item[\faUserInjured] The culprit here are optimization taking place by Java.
    They are only correctness-preserving in a single-threaded environment.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Visibility and stale data}

  \begin{block}{\faUserInjured\quad Stale data}
    Accessing out-of-date data due to the state of data (i.e. a variable being
    written upon) not being up-to-date across different threads. May lead to
    serious correctness issues.
  \end{block}
  \vspace{0.2cm}
  \begin{block}<2->{\faBriefcaseMedical\quad Solution}
    Always use synchronization to access shared data!
  \end{block}

  \begin{itemize}
  \item[\faBook]<2-> Synchronization causes writes to be visible across threads!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Visibility}

  \begin{center}
    \includegraphics[height=7cm,keepaspectratio]{../media/visibility.png}
  \end{center}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Is this thread-safe (2)}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
public class MutableInteger {
    private int value;

public int get() { return value; }
public void set(int value) { this.value = value; }
}
\end{lstlisting}

  \pause
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=3cm,starburst,starburst points=20,
      align=center,fill=yellow, opacity=1,draw=red, line width=2pt]
      {\textbf{No! \faSkullCrossbones}};
    \end{tikzpicture}

  \pause
\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
public class MutableInteger {
    private int value;

public int get() { return value; }
public synchronized void set(int value) { this.value = value; }
}
\end{lstlisting}

  \uncover<3->{
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=3cm,starburst,starburst points=20,
      align=center,fill=yellow, opacity=1,draw=red, line width=2pt]
      {\textbf{No! \faSkullCrossbones}};
    \end{tikzpicture}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Is this thread-safe (2)}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
public class MutableInteger {
    private int value;

public synchronized int get() { return value; }
public synchronized void set(int value) { this.value = value; }
}
\end{lstlisting}

    \begin{itemize}
  \item[\faBriefcaseMedical]<3-> The moral of the story is, intrinsic locks are
    not just for synchronization, but also for \textbf{visibility}. Use them
    when accessing shared variables, regardless if there are any apparent race
    conditions or not.
  \end{itemize}
  \uncover<2->{
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=3cm,starburst,starburst points=10,
      align=center,fill=green!50, opacity=1,draw=pink!50, line width=2pt]
      {\textbf{Yes}};
    \end{tikzpicture}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Out-of-thin-air safety}

  \begin{itemize}
  \item[\faBook] Staleness is not all-or-nothing
    \begin{itemize}
    \item[\faBook] One value might be fresh while another might be stale.
    \end{itemize}
  \item[\faBook] There is \textbf{almost} one thing that the developer can be sure when
    accessing stale data.
    \begin{itemize}
    \item[\faBook] Any value accessed to a shared memory location was caused by
      a write, and did not appear out of nowhere.
    \item[\faBook] This is known as \emph{out-of-thin-air} safety.
    \end{itemize}
  \item<2->[\faBook] It applies to \textbf{almost} any variable out there.
  \item<3->[\faBook] Except \texttt{double}'s and \texttt{long}'s.
  \end{itemize}

  \uncover<4->{By the way, remember DataRace.java?}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Volatility}

  \begin{block}{\texttt{Volatile} variables}
    The \texttt{volatile} modifier ensures that an attribute's value is always the same
    when read from any thread.
  \end{block}

  \begin{itemize}
  \item[\faBook]<1-> One sneaky way to ensure visibility is to use
    \texttt{volatile} variables.
  \item[\faBook]<1-> They achieve synchronization, as Java ensures that a read
    to a volatile variable will \emph{always} return the most recent value.
  \item[\faBook]<1-> They are neat and lightweight.
  \item[\faBook]<1-> Like locks, they also ensure that all variables prior to
    reading/writing a volatile variable are \emph{visible} across threads.
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Volatility}

  \begin{block}{\faBook \quad Remember!}
    Locking can guarantee both visibility and atomicity; volatile variables can
    only guarantee visibility.
  \end{block}

  You should use volatile variables only when all the following criteria are met:

  \begin{itemize}
  \item[\faBook]<1-> Writes to the variable do not depend on its current value,
    or you can ensure that only a single thread ever updates the value;
  \item[\faBook]<1-> The variable does not participate in invariants with other
    state variables, and
  \item[\faBook]<1-> Locking is not required for any other reason while the variable is being
    accessed.
  \end{itemize}

\end{frame}

\section{Publishing and sharing}

\begin{frame}[fragile]
  \frametitle{Publishing an object}

  \begin{itemize}
  \item[\faBook]<1-> You publish an object when it becomes available outside
    its scope, e.g. by passing its reference around.
  \item[\faBook]<1-> It is easy to inadvertently publish an object, so it is
    important to understand when publishing happens.
    \begin{itemize}
    \item[\faBook]<2-> We say that such objects have \emph{escaped}.
    \end{itemize}
  \item[\faUserInjured]<1-> There are also various pitfalls associated with
    publishing in a concurrent setting.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Publishing an object}

  \begin{itemize}
  \item[\faBook]<1-> Publishing an object can be as simple as using a public variable.
  \end{itemize}
\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
public static Set<Secret> knownSecrets;
public void initialize() {
    knownSecrets = new HashSet<Secret>();
}
\end{lstlisting}
  \pause
  \begin{itemize}
  \item[\faBook]<1-> Or returning an object.
  \end{itemize}
\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
class UnsafeStates {
    private String[] states =
        new String[] {"AK", "AL" ...};
    public String[] getStates() { return states; }
}
\end{lstlisting}
  \uncover<3->{
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=3cm,starburst,starburst points=40,
      align=center,fill=yellow, opacity=1,draw=red, line width=2pt]
      {\textbf{A \texttt{private} var gone public \faSkullCrossbones!}};
    \end{tikzpicture}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Publishing an object}

  \begin{itemize}
  \item[\faBook]<1-> All the way to rather obscure ways.
  \end{itemize}
\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(
            new EventListener() {
                public void onEvent(Event e) {
                    doSomething(e);
                }
            });
    }
}
\end{lstlisting}
  \uncover<2->{
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=2cm,starburst,starburst points=30,
      align=center,fill=yellow, opacity=1,draw=red, line width=2pt]
      {\textbf{\texttt{this} escape! \faSkullCrossbones}};
    \end{tikzpicture}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\texttt{this} escape}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
public class ThisEscape
    public ThisEscape(EventSource source)
        source.registerListener(
            new EventListener()
                public void onEvent(Event e)
                    doSomething(e);)
\end{lstlisting}

  \begin{itemize}
  \item[\faBook]<1-> After the \texttt{new} keyword, an anonymous class is being
    created, implementing \texttt{EventListener}.
  \item[\faBook]<2-> This class is shared to \texttt{source.registerListener}.
  \item[\faBook]<3-> Inner classes carry an implicit reference to \texttt{this}.
  \item[\faBook]<4-> Hence, \texttt{this} is shared... \pause in its
    \textbf{constructor} \faSkullCrossbones!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\texttt{this} escape (in constructor)}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
public class ThisEscape
    public ThisEscape(EventSource source)
        source.registerListener(
            new EventListener()
                public void onEvent(Event e)
                    doSomething(e);)
\end{lstlisting}

  \begin{block}{\texttt{\faBook} Important!}
    Do not allow the this reference to escape during construction. Another
    thread might get a hold of an object before it is properly initialized.
  \end{block}

  \begin{itemize}
  \item[\faBriefcaseMedical] A solution could(!) be to initialize the object in
    static method.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{How not to share}

  \begin{block}{Pro tip (ad-hoc confinement)}
    If you can \emph{ensure} that an object always stays within a thread, no
    synchronization is needed.
  \end{block}
  \vspace{0.2cm}
  \begin{block}{Stack confinement}
    Making sure objects can only be reached through local variables. As local
    variables are intrinsically tied to the execution of a thread, they cannot escape.
  \end{block}
  \vspace{0.2cm}
  \begin{block}{ThreadLocal confinement}
    Programmatic way to ensure that each thread keeps its own version of the object.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Immutability}

  \begin{itemize}
  \item[\faBook]<1-> One of your most effective tools towards thread-safety.
  \item[\faBook]<1-> An \emph{immutable} object is one whose state cannot be
    changed after its initialization.
  \end{itemize}
  \begin{block}<2->{\faBriefcaseMedical\quad Important}
    Immutable objects are always thread-safe.
  \end{block}
  \vspace{0.2cm}
  \begin{block}<2->{\faBook\quad Immutability}
    An object is immutable if the following are met:
    \begin{enumerate}
    \item  Its state cannot be modified after construction,
    \item All its fields are final, and
    \item  It is properly constructed (the this reference does not escape during
      construction).
    \end{enumerate}
  \end{block}


\end{frame}

\begin{frame}[fragile]
  \frametitle{Immutability}

  \begin{itemize}
    \item[\faBook] Is this object immutable?
  \end{itemize}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
public final class ThreeStooges {
  private final Set<String> stooges = new HashSet<String>();
  public ThreeStooges() {
    stooges.add("Moe");
    stooges.add("Larry");
    stooges.add("Curly");
  }
  public boolean isStooge(String name) {
    return stooges.contains(name);
  }
}
\end{lstlisting}
  \begin{itemize}
  \item[\faBook]<3-> It does not matter that \texttt{stooges} is a \texttt{Set}
    composed of mutable objects. What matters is that stooges itself is \texttt{final}.
  \end{itemize}
  \uncover<2->{
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=5cm,starburst,starburst points=10,
      align=center,fill=green!50, opacity=1,draw=pink!50, line width=2pt]
      {\textbf{Yes}};
    \end{tikzpicture}}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Immutability}

  \begin{block}<1->{\faBriefcaseMedical\quad Important}
    Just as it is a good practice to make all fields private unless they need
    greater visibility, it is a good practice to make all fields final
    unless they need to be mutable.
  \end{block}
  \pause
  \vspace{0.2cm}
  \begin{block}<1->{\faLightbulb\quad Tip}
    Just because an object is immutable, it doesn't mean that it can't \emph{represent}
    something mutable w.r.t. your program. You can always construct a
    \textbf{new} object with updated values.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Techniques for safe publishing (and sharing)}

  To publish a (non-immutable) object safely, both the reference to the object
  and the objectâ€™s state must be made visible to other threads at the same time. A properly
  constructed object can be safely published by:
  \begin{itemize}
  \item[\faBook] Initializing an object reference from a static initializer;
  \item[\faBook] Storing a reference to it into a volatile field or AtomicReference;
  \item[\faBook] Storing a reference to it into a final field of a properly constructed
    object; or
  \item[\faBook] Storing a reference to it into a field that is properly guarded by a
    lock.
  \end{itemize}

  \begin{block}<1->{\faBook\quad Remember}
    For objects whose state is going to change after publication, to ensure it's
    being used properly, it must be either thread-safe or guarded by a lock.
  \end{block}
\end{frame}

\section{Designing thread-safe classes}

\begin{frame}[fragile]
  \frametitle{Fundamental principles}

  The design process for a thread-safe class should
  include these three basic elements:

  \begin{itemize}
  \item[\faBook]<1-> Identify the object's \emph{state}, or \emph{state-space},
    i.e. its variables.
  \item[\faBook]<1-> Identify the \textbf{invariants}, meaning inherent
    properties of the state-space, that constraint its state-space
    during execution.
  \item[\faBook]<1-> Establish a synchronization policy so that concurrent
    access to  the object does not violate its invariants.
  \end{itemize}

  \pause
    \vspace{0.2cm}
    \begin{block}<1->{\faLightbulb\quad Tip}
      Encapsulation of state is your friend!
  \end{block}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Simple invariants}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
class SharedCounter {
    private int count = 0;

    public void increment() {
        count++;
    }
    public int getCount() { return count; }
}
\end{lstlisting}
    \begin{itemize}
  \item[\faBook]<2-> The state of SharedCounter is composed of count, and is
    already \textbf{encapsulated}.
  \item[\faBook]<2-> The implicit invariant that an increment should be atomic.
  \item[\faBook]<2-> Which policy should be used?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Simple invariants}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
class SharedCounter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }
    public synchronized int getCount() { return count; }
}
\end{lstlisting}
    \begin{itemize}
  \item[\faBook]<1-> One idea is to use intrinsic locking to protect the
    increment operation (will do for now).
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Complex invariants}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
  class NumberRange {
    private int min, max;

    public void setMin(int newMin) {
      if (newMin <= max)
           min = newMin;
    }
    public void setMax(int newMax) {
      if (newMax >= min)
           max = newMax;
    }
    public int getMin() { return min; }
    public int getMax() { return max; }
  }
\end{lstlisting}
  \uncover<2->{
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=4cm,starburst,starburst points=20,
      align=center,fill=yellow, opacity=1,draw=red, line width=2pt]
      {\textbf{Not thread-safe!}};
    \end{tikzpicture}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Complex invariants}

  \begin{itemize}
  \item[\faBook]<1-> Class \texttt{NumberRange} is not thread safe.
  \item[\faBook]<1-> No synchronization is used.
  \item[\faBook]<1-> The invariants are \emph{implicit}, i.e. no explanation is
    provided.
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Complex invariants (cont)}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
class AtomicNumberRange {
    private final AtomicInteger min = new AtomicInteger(0);
    private final AtomicInteger max = new AtomicInteger(100);

    public void setMin(int newMin) {
        if (newMin <= max.get())
            min.set(newMin);
    }
    public void setMax(int newMax) {
        if (newMax >= min.get())
            max.set(newMax);
    }
    public int getMin() { return min.get(); }
    public int getMax() { return max.get(); }
}
\end{lstlisting}
  \uncover<2->{
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=4cm,starburst,starburst points=20,
      align=center,fill=yellow, opacity=1,draw=red, line width=2pt]
      {\textbf{Not thread-safe!}};
    \end{tikzpicture}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Bad delegation}

  \begin{itemize}
  \item[\faBook]<1-> Class \texttt{AtomicNumberRange} is not thread safe.
  \item[\faBook]<1-> The developer is trying to \emph{delegate} thread safety to
    elements of the state space of the class itself.
  \item[\faBook]<1-> It doesn't work because the two variables are
    \textbf{interdependent}.
  \end{itemize}
  \vspace{0.2cm}
  \begin{block}<1->{\faLightbulb\quad Tip}
    If a class is composed of multiple independent thread-safe state variables
    and has no operations that have any invalid state transitions, then it can
    delegate thread safety to the underlying state variables.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Good delegation}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
class SafeCounter {
  private final AtomicInteger count = new AtomicInteger(0);

  public void increment() {
    count.incrementAndGet();
  }

  public int getCount() {
    return count.get();
  }
}
\end{lstlisting}
  \begin{itemize}
  \item[\faBook]<2-> The state-space is a single variable, and hence independent.
  \end{itemize}
  \uncover<2->{
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=4cm,starburst,starburst points=20,
      align=center,fill=green!50, opacity=1,draw=pink!50, line width=2pt]
      {\textbf{Thread-safe class!}};
    \end{tikzpicture}}

\end{frame}



\begin{frame}[fragile]
  \frametitle{Complex invariants (cont.)}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
  class SafeNumberRange {
    private int min, max;

    public synchronized void setMin(int newMin) {
      if (newMin <= max)
           min = newMin;
    }
    public synchronized void setMax(int newMax) {
      if (newMax >= min)
           max = newMax;
    }
    public synchronized int getMin() { return min; }
    public synchronized int getMax() { return max; }
  }
\end{lstlisting}
  \uncover<2->{
    \begin{tikzpicture}[overlay, remember picture]
      \node[xshift=10.4cm,yshift=4cm,starburst,starburst points=20,
      align=center,fill=green!50, opacity=1,draw=pink!50, line width=2pt]
      {\textbf{Thread-safe class!}};
    \end{tikzpicture}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Monitor pattern}

  \begin{itemize}
  \item[\faBook]<1-> Encapsulate all shared state.
  \item[\faBook]<1-> Use the same lock for \textbf{all} access to the shared state.
  \end{itemize}
  \vspace{0.2cm}
  \begin{block}<1->{\faLightbulb\quad Tip}
    Simple, yet effective.
  \end{block}
  \pause
  \begin{block}<1->{\faLightbulb\quad Tip}
      You could also try to use another, internal lock, in case a publicly
      accessible lock (like in the previous example) may cause liveness issues.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Code Listings}

  \begin{itemize}
  \item[\faCode]<1-> Visibility/Keepsgoing.java: example of visibility issue.
  \item[\faCode]<1-> Visibility/KeepsgoingFixed.java: fixed version of the above
    using sync.
  \item[\faCode]<1-> Visibility/Stale.java: more involved example on visibility,
    with two variables.
  \item[\faCode]<1-> Visibility/StaleFixed.java: one (of many) fixed version of
    the above.
  \item[\faCode]<1-> Publishing/ThisEscape*.java: examples on the unsafe publishing of \texttt{this}.
  \item[\faCode]<1-> Publishing/SafeThisEscape.java: example on the safe publishing of \texttt{this}.
  \item[\faCode]<1-> Design/GasTankRaceDemo.java: our familiar example on a
    compound invariant.
  \item[\faCode]<1-> Design/GasTankFixed.java: a fixed version of the above.
  \end{itemize}

  \begin{itemize}
  \item[\faCode]<1-> Also revisited Week10/DataRace.java: example of a Data
    Race due to operation on \texttt{long} being non-atomic.
  \end{itemize}
\end{frame}

\begin{frame}{}
  \centering \huge
  Thank you!
\end{frame}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End:
