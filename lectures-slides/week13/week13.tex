
\PassOptionsToPackage{colorlinks,linkcolor={blue},citecolor={blue},urlcolor={blue},breaklinks=true,final}{hyperref}
\PassOptionsToPackage{dvipsnames}{xcolor}
\documentclass[xcolor={dvipsnames,svgnames},aspectratio=169]{beamer}

\usepackage{fontawesome5}
\usepackage{booktabs} % For better table formatting
\usepackage{listings}

\lstset{
  tabsize = 4, %% set tab space width
  showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
  numbers = left, %% display line numbers on the left
  commentstyle = \color{purple!60}, %% set comment color
  keywordstyle = \color{blue}, %% set keyword color
  stringstyle = \color{red}, %% set string color
  rulecolor = \color{black}, %% set frame color to avoid being affected by text color
  basicstyle = \small \ttfamily , %% set listing font and size
  breaklines = true, %% enable line breaking
  numberstyle = \tiny,
}

\title{Concurrent Programming}
\subtitle{Week 13 (Lecture 5)}
\author{Stelios Tsampas}
\institute{
  \faEnvelope \; stelios@imada.sdu.dk
  \qquad
  \faGlobe \;
  \href{https://www.steliostsampas.com}{https://www.steliostsampas.com}
  \\\\\
  \faGithub \; stelios-tau/cp-2025
  \qquad\;\;
    \faDiscord \; cp-2025
}
\date{\today}

\titlegraphic{\includegraphics[height=0.6cm,keepaspectratio]{../media/sdu-black.eps}}

\usetheme[block=fill]{metropolis}


%\usepackage{pres-common}
\usepackage{textpos}
\usepackage{centernot}

% \newcommand{\Goesv}[3]{\ensuremath{#1 \xRightarrow{~#3~} #2}}
% \newcommand{\goesv}[3]{\ensuremath{#1 \xrightarrow{~#3~} #2}}

% \usepackage{etex}
% \usepackage{semantic}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{tikz}
\usepackage{hyperref}

\usetikzlibrary{arrows,shapes,matrix}
\usetikzlibrary{backgrounds}
\usetikzlibrary{positioning}
\usetikzlibrary{automata}
\usetikzlibrary{mindmap}
\usetikzlibrary{shapes.callouts}
\usetikzlibrary{decorations.text}
\usetikzlibrary{tikzmark}
\usetikzlibrary{calc}
\usetikzlibrary{overlay-beamer-styles}
\usetikzlibrary{shapes.geometric}
\usepackage{pgfplots}


\tikzset{onslide/.code args={<#1>#2}{%
    \only<#1>{\pgfkeysalso{#2}} % \pgfkeysalso doesn't change the path
  }}

\setbeamercolor{mygray}{bg=Gray!20}

\tikzset{temporal/.code args={<#1>#2#3#4}{%
    \temporal<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}}{\pgfkeysalso{#4}} % \pgfkeysalso doesn't change the path
  }}

\tikzstyle{highlight}=[fill=green!50]
\tikzstyle{hgreen}=[fill=green!20]
\tikzstyle{hred}=[fill=red!50]
\tikzstyle{hblue}=[fill=blue!50]
\tikzstyle{hgray}=[fill=gray!50]

\addtobeamertemplate{frametitle}{}{%
\begin{textblock*}{100mm}(\textwidth-2cm,-0.86cm)
\includegraphics[height=0.6cm,keepaspectratio]{../media/sdu-white.eps}
\end{textblock*}}


%\usepackage{tikz-cd}
% \usepackage{wasysym}
% \usepackage{color}
% \usepackage[matrix,arrow]{xy}
% \xyoption{all}
% \SelectTips{cm}{}
% % \usepackage{cite}
% \usepackage{amsthm}
% \usepackage{amsmath}
% \usepackage{bbold}
% % \usepackage[bbgreekl]{mathbbol}
% \usepackage{amssymb}
% \usepackage{pifont}
% \usepackage{mathtools}
% \usepackage{amsbsy}
% % \usepackage{paralist}
% \usepackage{shadethm}
% % \usepackage{fancyhdr}
% \usepackage{stmaryrd}
% \usepackage{wasysym}
% \usepackage{graphicx}
% \usepackage{tabularx}
% \usepackage{dsfont}
% \usepackage{ulem}




%\bibliography{mainBiblio}

%\includeonlyframes{current}
\begin{document}

\frame{\titlepage}

\def\firstcircle{(0,0) circle (2cm)}
\def\secondcircle{(1.4,1.4) circle (2cm)}
\def\thirdcircle{(0:2.4) circle (2cm)}

\begin{frame}{Outline}
  \tableofcontents
\end{frame}

\section{Recap}

\begin{frame}[fragile]
  \frametitle{Last week's topics}

  Last lecture, we touched upon...

  \begin{itemize}
  \item[\faBook]<1-> How to design software that can be
    \emph{utilized} safely in a concurrent setting.
  \item[\faBook]<1-> \emph{Visibility} in all its weirdness.
  \item[\faBook]<1-> The tricky topic of object \emph{sharing}.
  \item[\faBook]<1-> The role of \emph{invariants}, \emph{immutability} and
    \emph{encapsulation}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Some lessons so far}

  \begin{block}{\faBook\quad It's all about the mutable state.}
    All concurrency issues boil down to coordinating access to mutable
    state. The less mutable state, the easier it is to ensure thread safety.
  \end{block}

  \vspace{0.2cm}

  \begin{block}<2->{\faBook\quad Immutable objects are thread-safe.}
    Immutable objects simplify concurrent programming tremendously.
    They are simpler and safer, and can be shared freely without locking
    or defensive copying.
  \end{block}

  \vspace{0.2cm}

  \begin{block}<3->{\faBook\quad Encapsulation simplifies concurrency.}
    Organizes mutable states, hence organizes the invariants and makes them more
    manageable.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Some lessons so far (cont.)}

  \begin{itemize}
  \item[\faBook]<1-> If a field is not mutable, make it \textbf{final}.
  \item[\faBook]<1-> Guard each mutable variable with a \textbf{lock}.
  \item[\faBook]<1-> Guard all variables in an \textbf{invariant} with the
    \textbf{same} lock.
  \item[\faBook]<1-> Hold locks for the duration of compound actions.
  \item[\faBook]<1-> Don’t rely on visibility, obscure knowledge of the memory
    model or generally clever reasoning instead of synchronizing.
  \item[\faBook]<1-> Make thread safety a \textbf{central part} of your design
    process.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Learning flow}

  \begin{itemize}
  \item[\faBook]<1-> At this point, we are going to stop strictly, following the book's
    structure, like we have been doing. The lectures are going to center more
    around the Plans (and their videos) themselves.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{This week's topics}

  This week, we will witness that

  \begin{itemize}
  \item[\faBook]<1-> Spinlocks!
  \item[\faBook]<1-> Latches!
  \item[\faBook]<1-> Concurrent Collections!
  \end{itemize}

  \begin{itemize}
  \item[\faUserInjured]<2-> We will also demonstrate all of the above in
    examples.
  \end{itemize}
\end{frame}

\section{Spinlocks}

\begin{frame}[fragile]
  \frametitle{Why spin?}

  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{itemize}
      \item<1->[\faBook] It is a pattern (busy-wait) that a beginner coder could
        come up with.
      \item<2->[\faBook] Often not the best choice\dots
      \item<3->[\faBook] But situationally it makes sense!
      \end{itemize}

      \vspace{1cm}

      \begin{itemize}
      \item<4->[\faSearch] Basically the Garen of concurrency.
      \end{itemize}
    \end{column}
    \begin{column}{0.5\textwidth}  %%<--- here
      \uncover<4->{
      \begin{center}
        \includegraphics[height=7cm,keepaspectratio]{../media/garen.jpg}
      \end{center}}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What are spinlocks}

  \begin{block}{\faLock\quad Spinlock}
    A type of lock where a thread repeatedly checks if the lock is available.
  \end{block}

  \begin{itemize}
  \item[\faBook]<1-> A thread busy-waits in a loop ("spins") instead of sleeping.
  \item[\faBook]<1-> Example of a non-blocking synchronization primitive.
  \item[\faBook]<1-> Used when:
    \begin{itemize}
    \item[\faCheck] Critical section is very short.
    \item[\faCheck] Threads are expected to wait only briefly.
    \end{itemize}
  \end{itemize}

  \begin{block}<2->{\faLightbulb \quad Key idea}
    Avoid the overhead of OS thread context switches: the spinning thread will
    not get suspended immediately if it fails to acquire the lock. This is
    potentially good for performance, as suspending and resuming threads is
    expensive.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Busy-wait}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
while ((something) == 0) {
        /* do nothing - just keep checking over and over */
    }

doSomething();
\end{lstlisting}

  \vspace{0.2cm}
  \begin{block}<1->{\faLightbulb \quad Key idea}
    Wait -- and keep checking -- until a condition is met.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Spinlocks in Java}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
import java.util.concurrent.atomic.AtomicBoolean;
[...]
private final AtomicBoolean locked = new AtomicBoolean(false);
[...]
    while (!locked.compareAndSet(false, true)) {
            Thread.onSpinWait(); // Optional hint (Java 9+)
        }
    doSomething(;)
    locked.set(false);
[...]
\end{lstlisting}

  \begin{block}<1->{\faLightbulb \quad \texttt{compareAndSet}'s role}
  Sets \texttt{locked} to \texttt{true} if it is \texttt{false} (atomically).
  Returns \texttt{false} otherwise.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Compare with \texttt{synchronized}}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last ,
escapeinside={(*@}{@*)}]
private final Object lock = new Object();

public void doWorkWithSynchronizedLock() {
    synchronized (lock) {
        doSomething(); // critical section
    }
}
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Spinlock vs \texttt{synchronized} (Blocking)}
  \begin{table}[]
    \centering
    \begin{tabular}{l|l|l}
        \toprule
      \textbf{}
      & \textbf{Spinlock}
      & \textbf{Synchronized / Blocking Lock} \\
        \midrule
      \textbf{Behavior}
      & Active waiting (spins)
      & Passive waiting (thread blocks)\\
        \midrule
      \textbf{CPU Usage}
      & High during contention
      & Low (thread sleeps)\\
        \midrule
      \textbf{Context switch}
      & Avoided (keeps spinning)
      & Incurred (expensive) \\
        \midrule
      \textbf{Best for}
      & Low-contention, short tasks
      & Longer critical sections \\
        \bottomrule
    \end{tabular}
  \end{table}

  \begin{block}<2->{\faExclamationTriangle \quad Important}
    Spinlocks waste CPU if contention is high!
  \end{block}
\end{frame}

% Four million each
% Benchmark: SpinLock
% SpinLock   &  1 threads &  4000000 inc/thread & 23.90 ms \\
% SpinLock   &  2 threads &  4000000 inc/thread & 194.69 ms \\
% SpinLock   &  4 threads &  4000000 inc/thread & 804.36 ms \\
% SpinLock   &  8 threads &  4000000 inc/thread & 3058.44 ms \\
% SpinLock   & 16 threads &  4000000 inc/thread & 11280.23 ms \\

% spinlock without hint
% SpinLock   &  1 threads &  4000000 inc/thread & 23.79 ms \\
% SpinLock   &  2 threads &  4000000 inc/thread & 255.91 ms \\
% SpinLock   &  4 threads &  4000000 inc/thread & 821.17 ms \\
% SpinLock   &  8 threads &  4000000 inc/thread & 3142.18 ms \\
% SpinLock   & 16 threads &  4000000 inc/thread & 11278.40 ms \\

% Benchmark: synchronized
% synchronized &  1 threads &  4000000 inc/thread & 17.45 ms \\
% synchronized &  2 threads &  4000000 inc/thread & 130.45 ms \\
% synchronized &  4 threads &  4000000 inc/thread & 210.27 ms \\
% synchronized &  8 threads &  4000000 inc/thread & 351.00 ms \\
% synchronized & 16 threads &  4000000 inc/thread & 749.40 ms \\

% Benchmark: Nothing
% SpinLock   &  1 threads &  4000000 inc/thread & 8.28 ms \\
% SpinLock   &  2 threads &  4000000 inc/thread & 57.00 ms \\
% SpinLock   &  4 threads &  4000000 inc/thread & 126.49 ms \\
% SpinLock   &  8 threads &  4000000 inc/thread & 244.12 ms \\
% SpinLock   & 16 threads &  4000000 inc/thread & 486.06 ms \\



\begin{frame}[fragile]
  \frametitle{Spinlock vs \texttt{synchronized} (Blocking) vs nothing}

  \begin{center}
  \begin{tikzpicture}
    \begin{axis}[
%      ybar,
      symbolic x coords={1,2,4,8,16},
      xtick=data,
      xlabel={Threads},
      ylabel={Time (ms)},
      legend style={at={(1.3,1)},anchor=north}
      ]
      \addplot coordinates {(1,23.90) (2,194.69) (4,804.36)};
      \addplot coordinates {(1,23.79) (2,255.91) (4,821.17)};
      \addplot coordinates {(1,17.45) (2,130.45) (4,210.27)};
      \addplot coordinates {(1,8.28) (2,57.00) (4,126.49)};
      \legend{SpinLock, Spinlock (no-hint),synchronized, nothing}
    \end{axis}
  \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Spinlock vs \texttt{synchronized} (Blocking) vs nothing (cont.)}

  \begin{center}
  \begin{tikzpicture}
    \begin{axis}[
%      ybar,
      symbolic x coords={1,2,4,8,16},
      xtick=data,
      xlabel={Threads},
      ylabel={Time (ms)},
      legend style={at={(1.3,1)},anchor=north}
      ]
      \addplot coordinates {(1,23.90) (2,194.69) (4,804.36) (8,3058.44) (16,11280.23)};
      \addplot coordinates {(1,23.79) (2,255.91) (4,821.17) (8,3142.18) (16,11278.40)};
      \addplot coordinates {(1,17.45) (2,130.45) (4,210.27) (8,351.00) (16,749.40)};
      \addplot coordinates {(1,8.28) (2,57.00) (4,126.49) (8,244.12) (16,486.06)};
      \legend{SpinLock, Spinlock (no-hint),synchronized, nothing}
    \end{axis}
  \end{tikzpicture}
  \end{center}
\end{frame}

% 20 million each
% Benchmark: synchronized
% synchronized &  1 threads & 20000000 inc/thread & 77.39 ms \\
% synchronized &  2 threads & 20000000 inc/thread & 571.42 ms \\
% synchronized &  4 threads & 20000000 inc/thread & 990.07 ms \\
% synchronized &  8 threads & 20000000 inc/thread & 1789.19 ms \\
% synchronized & 16 threads & 20000000 inc/thread & 3600.88 ms \\
% synchronized & 32 threads & 20000000 inc/thread & 6927.95 ms \\

% Benchmark: Nothing
% SpinLock   &  1 threads & 20000000 inc/thread & 31.37 ms \\
% SpinLock   &  2 threads & 20000000 inc/thread & 315.02 ms \\
% SpinLock   &  4 threads & 20000000 inc/thread & 574.63 ms \\
% SpinLock   &  8 threads & 20000000 inc/thread & 1157.99 ms \\
% SpinLock   & 16 threads & 20000000 inc/thread & 2422.88 ms \\
% SpinLock   & 32 threads & 20000000 inc/thread & 4843.27 ms \\

\begin{frame}[fragile]
  \frametitle{\texttt{synchronized} (Blocking) vs nothing (cont.)}

  \begin{center}
  \begin{tikzpicture}
    \begin{axis}[
%      ybar,
      symbolic x coords={1,2,4,8,16,32},
      xtick=data,
      xlabel={Threads},
      ylabel={Time (ms)},
      legend style={at={(1.3,1)},anchor=north}
      ]
      \addplot coordinates {(1,77.39) (2,571.42) (4,990.07) (8,1789.19) (16,3600.88) (32,6927.95)};
      \addplot coordinates {(1,31.37) (2,315.02) (4,574.63) (8,1157.99) (16,2422.88) (32,4843.27)};
      \legend{synchronized, nothing}
    \end{axis}
  \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Spinlocks, the truth}
    \begin{itemize}
  \item[\faBook]<1-> Do spinlocks just suck then?!
  \item[\faBook]<2-> No not really, they are useful in certain cases, and see a lot of use
    in kernels and RTOS.
  \item[\faBook]<3-> Even the JVM uses it (see e.g. page 232 in the book)!
  \end{itemize}
  \vspace{0.6cm}
  \begin{block}<4->{\faPuzzlePiece \quad Challege time!}
    Can someone come up with a multi-threaded/concurrency situation/problem setting
    where spinlocking, under circumstances, performs consistently and visibly
    better than \texttt{synchronized}? First three to demonstrate win half-a-point!
  \end{block}
\end{frame}

\section{Latches (and task delegation)}

\begin{frame}[fragile]
  \frametitle{The Problem — Coordinating Threads}
  \begin{block}<1->{\faPuzzlePiece \quad The problem}
    You launch multiple threads to do some work... But how do you wait for all
    of them to finish before moving on?
  \end{block}

  For instance:
  \begin{itemize}
  \item[\faBook]<1-> Wait for all chefs to finish prep before serving.
  \item[\faBook]<1-> Wait for multiple services to initialize before starting the server.
  \item[\faBook]<1-> Wait for data loading to finish before processing.
  \item[\faBook]<1-> Wait for other threads to calculate a number, then perform
    an operation on their results.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introducing \texttt{CountDownLatch}}
  \begin{block}<1->{\faLightBulb \quad Key idea}
    A \texttt{CountDownLatch} lets one or more threads wait until a set of operations are completed.
  \end{block}

  For instance:
  \begin{itemize}
  \item[\faBook]<1-> Wait for all chefs to finish prep before serving.
  \item[\faBook]<1-> Wait for multiple services to initialize before starting the server.
  \item[\faBook]<1-> Wait for data loading to finish before processing.
  \item[\faBook]<1-> Wait for other threads to calculate a number, then perform
    an operation on their results.
  \end{itemize}
\end{frame}

\section{Concurrent Collections}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End:
